CREATE TABLE category(
	category_id	INT PRIMARY KEY,
	category_name VARCHAR(20)
	);

CREATE TABLE customers(
	customer_id	INT PRIMARY KEY,
	first_name	VARCHAR(15),
	last_name	VARCHAR(15),
	state VARCHAR(20),
	address VARCHAR(5) DEFAULT ('xxxx') -- if someone doesnt add address it will be written as xxxx
	);

CREATE TABLE sellers(
	seller_id	INT PRIMARY KEY,
	seller_name	VARCHAR(25),
	origin VARCHAR(10)
	);

CREATE TABLE products(
	product_id	INT PRIMARY KEY,
	product_name	VARCHAR(50),
	price	 NUMERIC(10,2),
	cogs	NUMERIC(7,2),
	category_id INT,
	CONSTRAINT product_fk_category FOREIGN KEY (category_id) REFERENCES category(category_id)
	); 

CREATE TABLE orders(
	order_id	INT PRIMARY KEY,
	order_date	DATE,  
	customer_id	INT,       -- FK
	seller_id	INT ,       -- FK
	order_status VARCHAR(15),
	CONSTRAINT order_id_fk_customers_id FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
	CONSTRAINT order_fk_sellers_id FOREIGN KEY (seller_id) REFERENCES sellers(seller_id)
	);

CREATE TABLE order_items(
	order_item_id	INT PRIMARY KEY,
	order_id	INT,    --FK
	product_id	INT,    --FK
	quantity	INT,
	price_per_unit NUMERIC(10,2),
	CONSTRAINT order_item_fk_products FOREIGN KEY(product_id) REFERENCES products(product_id),
	CONSTRAINT order_item_fk_order_id FOREIGN KEY (order_id) REFERENCES orders(order_id)
	);

CREATE TABLE payments(
	payment_id	INT PRIMARY KEY,
	order_id	INT,       -- FK
	payment_date	DATE,
	payment_status  VARCHAR(20),
	CONSTRAINT payments_fk_order_id FOREIGN KEY (order_id) REFERENCES orders(order_id)
	);

CREATE TABLE shipping(
	shipping_id	 INT PRIMARY KEY,
	order_id	INT,  -- FK
	shipping_date	DATE,
	return_date	DATE,
	shipping_providers	VARCHAR(25),
	delivery_status VARCHAR(15),
	CONSTRAINT shipping_fk_order_id FOREIGN KEY (order_id) REFERENCES orders(order_id)
	);

CREATE TABLE inventory(
	inventory_id INT PRIMARY KEY,
	product_id	INT,   --FK
	stock	INT,
	warehouse_id	INT,
	last_stock_date DATE,
	CONSTRAINT inventory_fk_product_id FOREIGN KEY (product_id) REFERENCES products(product_id)
	);

SELECT * FROM category;
SELECT * FROM customers;
SELECT * FROM sellers;
SELECT * FROM products;
SELECT * FROM orders;
SELECT * FROM order_items;
SELECT * FROM payments;
SELECT * FROM shipping;
SELECT * FROM inventory;

/*TRUNCATE TABLE table_name & ALTER TABLE table_name DROP CONSTRAIN constraint_fk_name on the table you need to fix data if needed
ALTER TABLE table_name ADD CONSTRAINT constraint_fk_name FOREIGN KEY (order_id) REFERENCES orders(order_id) */

/*Data Cleaning
Lets start by checking if there are any NULL/empty/unknown values in each table. Replace the table name for each respective table*/
SELECT *
FROM shipping
WHERE EXISTS (
    SELECT 1
    FROM json_each_text(to_json(shipping))
    WHERE value IS NULL OR value = ' ' OR value = 'N/A' OR value = 'Unknown'
);

/* Task 1. Top 10 products by total sales value, including the product name,
total quantity sold, and total sales value. */

SELECT 
	product_name,
	SUM(order_items.quantity) AS number_of_items_sold,
	SUM(order_items.price_per_unit * order_items.quantity) AS total_sales_value
	FROM order_items
JOIN products ON order_items.product_id = products.product_id
GROUP BY 1
ORDER BY 3 DESC
LIMIT 10;

/* Task 2. Calculating total revenue generated by each product category,
inlcuding the percentage contribution of each category to total revenue. */

WITH revenue AS(
SELECT 
	category_name,
	SUM(order_items.quantity*price_per_unit) AS revenue_per_category
	FROM order_items
JOIN products on order_items.product_id = products.product_id
JOIN category on products.category_id = category.category_id
GROUP BY 1)
SELECT 
	category_name,
	revenue_per_category,
	ROUND((revenue_per_category/SUM(revenue_per_category) OVER())*100, 2) || ' '|| '%' AS revenue_in_percentage -- OVER() so the rows wont collapse
	FROM revenue 
	group by 1,2;
	
/* Task 3. Computing the average order value for each customer,
including only customers with more than 5 orders. */

--Since total revenue (price*quantity) gets asked a lot, its important to make a column total_sales in the order_items

ALTER TABLE order_items
ADD COLUMN total_sales NUMERIC(10,2)

UPDATE order_items
SET total_sales = quantity*price_per_unit

-- This could have been done since task number 1 and 2 and we wouldnt have needed to use window function.

SELECT
first_name || ' ' || last_name AS full_name,
ROUND(AVG(total_sales), 2) AS average_revenue_per_customer,
COUNT(order_items.order_id) AS orders_per_customer
FROM order_items
JOIN orders ON order_items.order_id = orders.order_id
JOIN customers ON orders.customer_id = customers.customer_id
GROUP BY 1
HAVING COUNT(order_items.order_id) > 5        -- HAVING instead of WHERE. Aggregate functions are not allowed in WHERE
ORDER BY 3 ASC;

/* Task 4. Querying monthly total sales over the past year where I will display
the sales trend, grouping by month, return current_month sale, last month sale! */
-- One way to approach to it. This only returns monthly totals, not current vs last month in separate columns
SELECT 
	TO_CHAR(order_date, 'YYYY-MM') AS month,
	SUM(total_sales) AS monthly_sales
	FROM orders
JOIN order_items on orders.order_id = order_items.order_id
	WHERE order_date >= CURRENT_DATE - INTERVAL '1 YEAR'
	GROUP BY 1
	ORDER BY 1 DESC; 

-- The other way to show current month and last month in seperate columns

SELECT 
	year,
	month,
	monthly_sales,
	LAG(monthly_sales, 1) OVER(ORDER BY year,month) AS previous_month_Sales  -- LAG by 1 (one month) , you can remove ORDER BY inside the ()
FROM
(
SELECT 
		EXTRACT(YEAR FROM order_date) AS year,
		EXTRACT(MONTH FROM order_date) AS month,
		SUM(order_items.total_sales) as monthly_sales
FROM order_items
JOIN orders on orders.order_id = order_items.order_id
WHERE order_date >= CURRENT_DATE - INTERVAL '1 YEAR'
GROUP BY 1,2
ORDER BY 1, 2 ASC ) AS t1

-- Task 5. Finding customers who have registered but never placed an order and the customer details. 

SELECT 
	customers.*,
	orders.order_id
FROM customers
LEFT JOIN orders ON orders.customer_id = customers.customer_id
	WHERE order_id IS NULL

-- Another approach to this task is using a subquery

SELECT * FROM customers
WHERE customer_id NOT IN(SELECT 
DISTINCT customer_id
FROM orders
)

/* Task 6. Identifying the least-selling product category for each state including the total sales 
for that category within each state.*/

WITH cte AS
(SELECT
	customers.state,
	category.category_name,
	SUM(order_items.total_sales) AS total_sales_per_category,
	RANK() OVER(PARTITION BY customers.state ORDER BY SUM(order_items.total_sales) ASC ) AS ranked --ASC so that the lowest value = rank 1
FROM customers
JOIN orders ON customers.customer_id = orders.customer_id
JOIN order_items ON orders.order_id = order_items.order_id
JOIN products ON order_items.product_id = products.product_id
JOIN category ON products.category_id = category.category_id
GROUP BY 1,2 )
SELECT 	
	state,
	total_sales_per_category,
	category_name AS least_selling_category
FROM cte
WHERE ranked = 1  -- so the least_selling_category returns the lowest value from the RANK() & OVER() window functions
order by 2 DESC;

-- I can do a quick verification from this query
SELECT 
	category_name,
	SUM(total_sales)
FROM customers
JOIN orders ON customers.customer_id = orders.customer_id
JOIN order_items ON orders.order_id = order_items.order_id
JOIN products ON order_items.product_id = products.product_id
JOIN category ON products.category_id = category.category_id
WHERE state = 'North Dakota'
GROUP BY 1
ORDER BY 2 DESC;

/* Task 7. Calculating the total value of orders placed by each customer over their lifetime.
Ranking customers based on their CLTV (Customer LifeTime Value). */

SELECT 
	orders.customer_id,
	first_name || ' ' || last_name AS full_name,
	SUM(total_sales) AS CLTV ,
	RANK() OVER(ORDER BY SUM(total_sales) ASC) AS rank
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
JOIN order_items ON orders.order_id = order_items.order_id
GROUP BY 1,2

-- Task 8. Querying products with stock levels below 10 units including last restock date. 

SELECT 
	products.product_id,
	product_name,
	stock,
	last_stock_date
FROM inventory
JOIN products on inventory.product_id = products.product_id
WHERE stock < 10

/* Task 9. Identifying orders where the shipping date is later than 3 days after the order date, inlcuding
customer, order details, and delivery provider. */

SELECT
	first_name || ' ' || last_name AS full_name,
	customers.customer_id,
	state,
	orders.order_id,
	orders.seller_id,
	orders.order_status,
	shipping_providers,
	order_date,
	shipping_date,
	shipping_date - order_date AS days_took_to_ship
FROM shipping
JOIN orders on shipping.order_id = orders.order_id
JOIN customers on orders.customer_id = customers.customer_id
WHERE shipping_date > order_date + INTERVAL '3 DAY'
ORDER BY 10 DESC;

/* Task 10. Calculating the percentage of successful payments across all orders including
breakdowns by payment status. */

WITH cte AS (
	SELECT 
	COUNT(payment_id) AS number_of_payments,
	payment_status
	FROM payments
	GROUP BY 2 )
SELECT 
	number_of_payments,
	payment_status,
	ROUND(number_of_payments/SUM(number_of_payments) OVER() * 100, 2) AS payment_status_in_percentage
FROM cte

/* Task 11. Finding the top 5 sellers based on total sales value including both successful and failed orders, 
and display their percentage of successful orders. */

WITH 
top_sellers AS(
SELECT 
	sellers.seller_id,
	sellers.seller_name,
	SUM(total_sales) AS revenue_per_seller
FROM order_items
JOIN orders on order_items.order_id = orders.order_id
JOIN sellers ON orders.seller_id = sellers.seller_id
GROUP BY 1,2
ORDER BY 3 desc
LIMIT 5

),

/* Now that we found top5 sellers by revenue, lets see how many total orders they received and their status */

seller_order_status
AS (
SELECT 
	order_status,
	top_sellers.seller_id,
	top_sellers.seller_name,
	COUNT(*) AS total_orders
from orders
JOIN top_sellers ON orders.seller_id = top_sellers.seller_id
WHERE order_status NOT IN ('Returned', 'Inprogress')
GROUP BY 1,2,3
ORDER BY 4 DESC
),

/* FROM 5 rows inside CTE1 (top_sellers) now we have 10 rows when we join those 2 tables together, 
5x2 because there are only 2 values for order_status (Completed and Cancelled) after we removed Returned and Inprogress */

cte3
AS (
SELECT 
	seller_id,
	seller_name,
	SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END) AS completed_orders,
	SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END) AS cancelled_orders,
	SUM(total_orders) AS total_orders
from seller_order_status
GROUP BY 1,2
order by 2
) 

SELECT
	cte3.seller_id,
	cte3.seller_name,
	completed_orders,
	cancelled_orders,
	cte3.total_orders,
	'%' || ' ' || ROUND((completed_orders/total_orders)*100, 2) AS successful_orders
FROM cte3
GROUP BY 1,2,3,4,5

-- Task 12. Calculating the profit margin for each product while ranking products by their profit margin, showing highest to lowest. 

WITH metrics AS (
SELECT
	products.product_id,
	product_name,
	SUM(total_sales) AS total_sales,
	SUM(cogs) AS cogs
FROM order_items
JOIN products on order_items.product_id = products.product_id
GROUP BY 1,2
ORDER BY 3 DESC )
SELECT 
	product_id,
	product_name,
	total_sales,
	cogs,
	(total_sales - cogs) AS profit,
	'%'|| ' ' || ROUND(((total_sales - cogs)/total_sales)*100,2) AS profit_in_percentage,
	RANK() OVER(ORDER BY (total_sales - cogs) DESC) AS rank
	FROM metrics

/* Task 13. Querying the top 10 products by the number of returns while displaying
the return rate as a percentage of total units sold for each product. */

SELECT
	products.product_id,
	product_name,
	SUM(quantity) AS total_units_sold,
	SUM(CASE WHEN orders.order_status = 'Returned' THEN 1 ELSE 0 END) AS returns,
	'%' || ' ' || ROUND(SUM(CASE WHEN orders.order_status = 'Returned' THEN 1 ELSE 0 END)::numeric/SUM(quantity)*100, 2) AS return_rate
FROM order_items
JOIN orders ON orders.order_id = order_items.order_id
JOIN shipping ON orders.order_id = shipping.order_id
JOIN products ON order_items.product_id = products.product_id
WHERE return_date IS NOT NULL
GROUP BY 1,2
ORDER BY 4 DESC
LIMIT 10

-- Here you can confirm Apple AirPods Pro has been returned 19 times
SELECT * FROM order_items
JOIN orders ON orders.order_id = order_items.order_id
JOIN shipping ON orders.order_id = shipping.order_id
JOIN products ON order_items.product_id = products.product_id
WHERE product_name = 'Apple AirPods Pro' AND return_date IS NOT NULL

/* Task 14. Identifying sellers who havenâ€™t made any sales in the last 6 months, while showing
the last sale date and total sales from those sellers. */

SELECT
	sellers.seller_id,
	seller_name,
	SUM(total_sales) AS revenue_per_seller,
	MAX(order_date) AS latest_order
FROM order_items
JOIN orders ON order_items.order_id = orders.order_id
JOIN sellers ON orders.seller_id = sellers.seller_id
WHERE order_date < CURRENT_DATE - INTERVAL '6 MONTH'
GROUP BY 1,2
ORDER BY 3 DESC;

/* Task 15. Identifying customers into returning or new. Customers who have done more than 5 orders will be categorized
as returning customers, otherwise as new. */
WITH base_data AS 
(
SELECT 
	customers.customer_id,
	first_name || ' ' || last_name AS customer_name,
	COUNT(*) AS total_orders
FROM orders
JOIN customers on orders.customer_id = customers.customer_id
GROUP BY 1,2)
SELECT 
	base_data.*,
	CASE
		WHEN total_orders > 5 THEN 'returning customer'
		ELSE 'new'
		END AS customer_type
	FROM base_data


-- Task 16. Next Day Delivery**: Listing all orders that were delivered the next day after shipping.
SELECT
	orders.order_id,
	order_date,
	shipping_date
FROM orders
JOIN shipping on orders.order_id = shipping.order_id
WHERE shipping_date = order_date + INTERVAL '1 DAY'

/* Task 17. Identifying the top 5 customers with the highest number of orders for each state,
including the number of orders and total sales for each customer. */

WITH cte1 AS (
SELECT
	customers.customer_id,
	first_name || ' ' || last_name AS customer_name,
	state,
	sum(total_sales) AS total_sales,
	COUNT(*) AS total_orders
FROM order_items
JOIN orders ON order_items.order_id = orders.order_id
JOIN customers ON orders.customer_id = customers.customer_id
GROUP BY 1,2,3 ),
cte2 AS(
SELECT 
	*,
	ROW_NUMBER() OVER(PARTITION BY state ORDER BY total_orders DESC) AS rank
	FROM cte1 )
SELECT 
	* FROM cte2
	WHERE rank <= 5
	ORDER BY 3

/* Task 18. Calculating the total revenue handled by each shipping provider,including the total number of orders
handled and the average delivery time for each provider. */

SELECT 
	shipping_providers,
	SUM(total_sales) AS total_revenue,
	COUNT(*) AS total_orders,
	COALESCE(ROUND(AVG(shipping_date - order_date)), 0) || ' ' || 'Days' AS average_delivery_time
FROM order_items
JOIN orders ON order_items.order_id = orders.order_id
JOIN shipping on orders.order_id = shipping.order_id
GROUP BY 1

-- Task 19. Top 10 products with highest decreasing revenue ratio compare to last year and current_year

WITH year2024 AS(
SELECT
	products.product_id,
	products.product_name,
	category.category_name,
	SUM(total_sales) AS ly_revenue
FROM orders
JOIN order_items ON orders.order_id = order_items.order_id
JOIN products ON order_items.product_id = products.product_id
JOIN category ON products.category_id = category.category_id
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31'
GROUP BY 1,2,3),

year2025 AS (
	SELECT
	products.product_id,
	products.product_name,
	category.category_name,
	SUM(total_sales) AS cy_revenue
FROM orders
JOIN order_items ON orders.order_id = order_items.order_id
JOIN products ON order_items.product_id = products.product_id
JOIN category ON products.category_id = category.category_id
WHERE order_date BETWEEN '2025-01-01' AND '2025-12-31'
GROUP BY 1,2,3),

cte3 as (SELECT 
	year2024.product_name,
	year2024.category_name,
	ly_revenue,
	cy_revenue
	FROM year2024
	JOIN year2025 on year2024.product_id = year2025.product_id)

SELECT 
	*,
	ROUND(((cy_revenue - ly_revenue)/ ly_revenue) * 100, 2) AS change_ratio
	FROM cte3
	ORDER BY 5 ASC
	LIMIT 10;	
	
/* Task 20. Creating a stored procedure that, when a product is sold, performs the following actions:
Inserts a new sales record into the orders and order_items tables.
Updates the inventory table to reduce the stock based on the product and quantity purchased.
The procedure should ensure that the stock is adjusted immediately after recording the sale. */

CREATE OR REPLACE PROCEDURE new_orders
/* below I will write mandatory information needed to fill all the values for both orders and order_items tables, you don't need to
mention price_per_unit or total_sales because those are fixed values automatically determined by product ID */
(p_order_id INT, p_customer_id INT, p_seller_id INT, p_order_item_id INT, p_product_id INT, p_quantity INT) 
LANGUAGE plpgsql
AS $$

DECLARE
	v_count INT;
	v_price NUMERIC(19,2);
	v_product_name VARCHAR(50);
BEGIN
	SELECT
	product_name
	INTO
	v_product_name
	FROM products
	WHERE product_id = p_product_id;
	
	SELECT 
	price
	INTO
	v_price
	FROM products 
	WHERE product_id = p_product_id;
		
	SELECT 
	COUNT(*)
	INTO
	v_count
	FROM inventory 
	WHERE product_id = p_product_id
	AND
	stock >= p_quantity; -- must be greater than what quantity the customer has ordered
	
	
	IF v_count > 0 
	THEN
	--then insert into tables orders and order_items
	-- update stock in inventory table
	INSERT INTO orders (order_id, order_date, customer_id, seller_id) 
	VALUES (p_order_id, CURRENT_DATE, p_customer_id, p_seller_id );
	INSERT INTO order_items (order_item_id,order_id, product_id, quantity, price_per_unit, total_sales)
	VALUES (p_order_item_id,p_order_id, p_product_id, p_quantity, v_price, v_price * p_quantity );

	UPDATE inventory
	SET stock = stock - p_quantity
	WHERE product_id = p_product_id;

	RAISE NOTICE 'Thank you for your information the product : %  has been added in the records and inventory has been updated',v_product_name; 
	ELSE 
	RAISE NOTICE 'Thank you for your information the product : % is not available at the moment', v_product_name;
	END IF;
	
END;
$$

SELECT * FROM inventory
WHERE product_id = 2  -- product_id = 2 AND currently stock is 39, and a new order has arrived with 2 quantities of this product ID

CALL new_orders (21630, 17, 5, 21630, 2, 2); /* Do NOT use quotes for numbers 
or else you get an ERROR unknown (they count as strings while their DATA is INT ) */

/* NOTE! column stock, p_seller_id  AND p_product_id should not be random. They should correlate with each other
so for that I execute the query below so it will work properly */
-- Now let's check 

SELECT * FROM inventory
WHERE product_id = 2  -- Stock is now 39-2=37

SELECT * FROM order_items
WHERE order_id = 21630 -- new record has been added

SELECT * FROM orders
WHERE order_id = 21630 -- new record has been added



	
